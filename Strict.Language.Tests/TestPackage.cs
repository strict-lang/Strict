namespace Strict.Language.Tests;

/// <summary>
/// Helper context to provide a bunch of helper types to make tests work.
/// </summary>
public class TestPackage : Package
{
	public static readonly Package Instance = new TestPackage();

	private TestPackage() : base(nameof(TestPackage))
	{
		var parser = new MethodExpressionParser();
		// @formatter:off
		var any = new Type(this, new TypeLines(Base.Any,
			"from", "to Type", "to Text", "is(other) Boolean", "not(other) Boolean"));
		var boolean = new Type(this, new TypeLines(Base.Boolean,
			"not Boolean",
			"\tnot true is false",
			"\tvalue ? false else true",
			"is(other) Boolean",
			"\tvalue is other",
			"and(other) Boolean",
			"\tvalue and other ? true else false",
			"or(other) Boolean",
			"\tvalue or other ? false else true",
			"xor(other) Boolean",
			"\ttrue xor false is true",
			"\tfalse xor false is false",
			"\t(value and other) or ((not value) and (not other)) ? false else true"));
		var hasLength = new Type(this, new TypeLines("HasLength","Length Number"));
		var number = new Type(this, new TypeLines(Base.Number,
			"to Character",
			"\tconstant canOnlyConvertSingleDigit = Error",
			"\tvalue is in Range(0, 10) ? Character(Character.zeroCharacter + value) else canOnlyConvertSingleDigit(value)",
			"is not(other) Boolean",
			"\t1 is not 3",
			"\t2 is not 3",
			"\tvalue != other",
			"is not in(other) Boolean",
			"\t1 is not in (3, 4)",
			"\t2 is not in (1, 3, 5)",
			"\tfor currentValue in other",
			"\t\tif currentValue is value",
			"\t\t\treturn false",
			"\ttrue",
			"is in(other) Boolean",
			"\t1 is in (3, 4)",
			"\t2 is in (1, 3, 5)",
			"\tfor currentValue in other",
			"\t\tif currentValue is value",
			"\t\t\treturn true",
			"\tfalse",
			"+(other) Number",
			"\t3 + 4 is 7",
			"\tvalue + other",
			"*(other) Number",
			"\tvalue * other",
			"-(other) Number",
			"\tvalue - other",
			"/(other) Number",
			"\tvalue / other",
			"Floor Number",
			"\tvalue - value % 1",
			"%(other) Number",
			"\tvalue % other",
			">(other) Boolean",
			"\tvalue > other",
			"<(other) Boolean",
			"\tvalue < other",
			"^(other) Number",
			"\tvalue ^ other",
			"to Text",
			"\t\"\" + value",
			"is(other) Boolean",
			"\t5 is 5 is true",
			"\t6 is 5 is false",
			"\tvalue is other"));
		var range = new Type(this, new TypeLines(Base.Range,
			"has iterator",
			"has Start Number",
			"has End Number",
			"Length Number",
			"\tRange(0, 5).Length is 5",
			"\tRange(2, 18).Length is 16",
			"\tEnd - Start",
			"in(element Number) Boolean",
			"\t3 in Range(1, 4) is true",
			"\t5 in Range(1, 4) is false",
			"\t0 in Range(1, 4) is false",
			"\telement >= Start and element <= End",
			"Sum",
			"\tRange(2, 5).Sum is 2 + 3 + 4",
			"\tRange(42, 45).Sum is 42 + 43 + 44",
			"\tfor",
			"\t\t+ value",
			"for Number",
			"\tStart",
			"Reverse Range",
			"\tRange(0, 5).Reverse is Range(4, -1)",
			"\tRange(1, 4).Reverse is Range(3, 0)",
			"\tRange(10, 5).Reverse is Range(6, 11)",
			"\tRange(-5, -10).Reverse is Range(-9, -4)",
			"\tLength > 0 ? Range(ExclusiveEnd - 1 , Start - 1)\telse Range(ExclusiveEnd + 1, Start + 1)"));
		var character = new Type(this, new TypeLines(Base.Character,
			"has number",
			"constant zeroCharacter = 48",
			"constant NewLine = Character(13)",
			"constant Tab = Character(7)",
			"to Number",
			"\tCharacter(\"3\") to Number is 3",
			"\tconstant notANumber = Error",
			"\tCharacter(\"A\") to Number is notANumber",
			"\tconstant result = number - zeroCharacter",
			"\tresult is in Range(0, 10) ? result else notANumber(value)"));
		var mutable = new Type(this, new TypeLines(Base.Mutable,
			"has generic"));
		var iterator = new Type(this, new TypeLines(Base.Iterator,
			"for Iterator(Generic)",
			"in(element Generic) Boolean",
			"Length Number"));
		var list = new Type(this, new TypeLines(Base.List,
			"has iterator",
			"has elements Generics",
			"Length Number",
			"\t(1, 2).Length is 2",
			"\tmutable length = 0",
			"\tfor elements",
			"\t\tlength = length + 1",
			"\tlength",
			"+(other) List",
			"\t(1, 2, 3) + (4, 5) is (1, 2, 3, 4, 5)",
			"\t(\"Hello\", \"World\") + (1, 2) is (\"Hello\", \"World\", \"1\", \"2\")",
			"\tvalue + other",
			"+(addElement Generic) List",
			"\t(1, 2, 3) + 4 is (1, 2, 3, 4)",
			"\t(\"Hello\", \"World\") + 5 is (\"Hello\", \"World\", \"5\")",
			"\telements + addElement",
			"-(other) List",
			"\t(1, 2, 3) - (3) is (1, 2)",
			"\tvalue - other",
			"-(removeElement Generic) List",
			"\t(1, 2, 3) - 3 is (1, 2)",
			"\t(1, 2, 3) - 4 is (1, 2, 3)",
			"\telements - removeElement",
			"is(other) Boolean",
			"\tvalue is other",
			"*(other) List",
			"\t(1, 2) * (3, 5) is (3, 10)",
			"\tconstant listsHaveDifferentDimensions = Error",
			"\t(1) * (1, 2) is listsHaveDifferentDimensions",
			"\tif Length is not other.Length",
			"\t\tlistsHaveDifferentDimensions",
			"\telements * other.elements",
			"Contains(other Generic) Boolean",
			"\t(\"a\", \"b\", \"c\").Contains(\"d\") is false",
			"\t(\"a\", \"b\", \"c\").Contains(\"b\") is true",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn true",
			"\tfalse",
			"Index(other Generic) Number",
			"\t(1, 2, 3).Index(2) is 1",
			"\t(1, 2, 3).Index(9) is -1",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn index",
			"\t-1",
			"for Generic",
			"\tfor elements",
			"\t\treturn value",
			"in(other) Boolean",
			"\t3 is in (1, 2, 3)",
			"\t3 is not in (1, 2)",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn true",
			"\tfalse",
			"Add(element Generic) Mutable(List)",
			"\t(1, 2).Add(3) is (1, 2, 3)",
			"\tvalue = value + element",
			"Remove(element Generic) Mutable(List)",
			"\t(1, 2, 3).Remove(2) is (1, 3)",
			"\tvalue = value - element",
			"Count(element Generic) Number",
			"\t(1, 2).Count(1) is 1",
			"\t(1, 3).Count(2) is 0",
			"\t(\"Hi\", \"Hello\", \"Hi\").Count(\"Hi\") is 2",
			"\tmutable occurrenceCount = 0",
			"\tfor elements",
			"\t\tif element is value",
			"\t\t\toccurrenceCount.Increment",
			"\tcount"));
		var text = new Type(this, new TypeLines(Base.Text,
			"has characters",
			"from(number)",
			"\tvalue",
			"Run",
			"\tvalue is not \"\"",
			"+(other) Text",
			"\tvalue + other",
			"digits(number) Numbers",
			"\tif floor(number / 10) is 0",
			"\t\treturn (number % 10)",
			"\telse",
			"\t\treturn digits(floor(number / 10)) + number % 10",
			"to Number",
			"\t\"3\" to Number is 3",
			"\tfor characters.Reverse",
			"\t\t+ value to Number * index ^ 10",
			"is(other) Boolean",
			"\t\"Hey\" is \"Hey\" is true",
			"\t\"Hi\" is \"Hey\" is false",
			"\tvalue is other",
			"is not(other) Boolean",
			"\t\"A\" is not \"B\"",
			"\t\"Hi\" is not \"hi\"",
			"\tvalue is not other"));
		var baseType = new Type(this, new TypeLines(Base.Type, "has Name",
			"has Package Text",
			"to Text",
			"\tto Text is \"Strict.Base.Type\"",
			"\tPackage + \".\" + Name"));
		var generic = new Type(this, new TypeLines(Base.Generic, "from(type)"));
		var logger = new Type(this, new TypeLines(Base.Logger,
			"has textWriter",
			"Log(text)",
			"\ttextWriter.Write(text)"));
		var file = new Type(this, new TypeLines(Base.File,
			"from(text)",
			"Read Text",
			"Write(text)",
			"Delete",
			"Length Number"));
		var textWriter = new Type(this, new TypeLines(Base.TextWriter, "Write(text)"));
		var textReader = new Type(this, new TypeLines(Base.TextReader, "Read Text"));
		var name = new Type(this, new TypeLines(Base.Name, "has text"));
		var error = new Type(this, new TypeLines(Base.Error, "has Text", "has Stacktraces"));
		var method = new Type(this, new TypeLines(Base.Method, "has Name", "has Type"));
		var stacktrace = new Type(this, new TypeLines(Base.Stacktrace,
			"has Method", "has FilePath Text", "has Line Number"));
		var dictionary = new Type(this, new TypeLines(Base.Dictionary,
			"has keysAndValues List(key Generic, mappedValue Generic)",
			"from",
			"\tDictionary(Number, Number).Length is 0",
			"\tDictionary(Number, Number) is Dictionary(Number, Number)",
			"\tDictionary(Number, Number) is not Dictionary(Number, Text)",
			"Add(key Generic, mappedValue Generic) Mutable(Dictionary)",
			"\tDictionary((2, 4)).Add(4, 8) is Dictionary((2, 4), (4, 8))",
			"\tDictionary((1, 1), (2, 2)).Add(3, 3).Length is 3",
			"\tkeysAndValues.Add((key, mappedValue))",
			"Get(key Generic) Generic",
			"\tfor keysAndValues",
			"\t\tif value(0) is key",
			"\t\t\treturn value(1)",
			"\tError(\"Key \" + key + \" not found\")"));
		// @formatter:on
		foreach (var type in new[]
			{
				any, boolean, hasLength, number, range, character, mutable, iterator, list, text, baseType,
				generic, logger, file, textWriter, textReader, name, error, method, stacktrace, dictionary
			})
			type.ParseMembersAndMethods(parser);
	}
}