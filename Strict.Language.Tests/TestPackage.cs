using Strict.Language.Expressions;

namespace Strict.Language.Tests;

/// <summary>
/// Helper context to provide a bunch of helper types to make tests work.
/// </summary>
public class TestPackage : Package
{
	public TestPackage() : base(nameof(TestPackage))
	{
		var parser = new MethodExpressionParser();
		// @formatter:off
		var any = new Type(this, new TypeLines(Base.Any,
			"to Type", "to Text", "is(other) Boolean", "not(other) Boolean"));
		var boolean = new Type(this, new TypeLines(Base.Boolean,
			"not Boolean",
			"\tvalue ? false else true",
			"is(other) Boolean",
			"\tvalue is other",
			"and(other) Boolean",
			"\tvalue and other ? true else false",
			"or(other) Boolean",
			"\tvalue or other ? false else true",
			"xor(other) Boolean",
			"\t(value and other) or (not value and not other) ? false else true",
			"not Boolean",
			"\tnot true is false",
			"\tvalue ? false else true"));
		var hasLength = new Type(this, new TypeLines("HasLength","Length Number"));
		var number = new Type(this, new TypeLines(Base.Number,
			"is not(other) Boolean",
			"\t1 is not 3",
			"\t2 is not 3",
			"\tvalue != other",
			"is not in(other) Boolean",
			"\t1 is not in (3, 4)",
			"\t2 is not in (1, 3, 5)",
			"\tfor currentValue in other",
			"\t\tif currentValue is value",
			"\t\t\treturn false",
			"\treturn true",
			"is in(other) Boolean",
			"\t1 is in (3, 4)",
			"\t2 is in (1, 3, 5)",
			"\tfor currentValue in other",
			"\t\tif currentValue is value",
			"\t\t\treturn true",
			"\treturn false",
			"+(other) Number",
			"\t3 + 4 is 7",
			"\tvalue + other",
			"*(other) Number",
			"\tvalue * other",
			"-(other) Number",
			"\tvalue - other",
			"/(other) Number",
			"\tvalue / other",
			"Floor Number",
			"\tvalue - value % 1",
			"%(other) Number",
			"\tvalue % other",
			">(other) Boolean",
			"\tvalue > other",
			"<(other) Boolean",
			"\tvalue < other",
			"^(other) Number",
			"\tvalue ^ other",
			"to Text",
			"\t\"\" + value",
			"is(other) Boolean",
			"\t5 is 5 is true",
			"\t6 is 5 is false",
			"\tvalue is other"));
		var range = new Type(this, new TypeLines(Base.Range,
			"has iterator",
			"has Start Number",
			"has End Number",
			"Length Number",
			"\tRange(0, 5).Length is 5",
			"\tRange(2, 18).Length is 16",
			"\tEnd - Start",
			"in(element Number) Boolean",
			"\t3 in Range(1, 4) is true",
			"\t5 in Range(1, 4) is false",
			"\t0 in Range(1, 4) is false",
			"\telement >= Start and element <= End",
			"Sum",
			"\tRange(2, 5).Sum is 2 + 3 + 4",
			"\tRange(42, 45).Sum is 42 + 43 + 44",
			"\tfor",
			"\t\t+ value",
			"for Number",
			"\tStart",
			"Reverse Range",
			"\tRange(0, 5).Reverse is Range(4, -1)",
			"\tRange(1, 4).Reverse is Range(3, 0)",
			"\tRange(10, 5).Reverse is Range(6, 11)",
			"\tRange(-5, -10).Reverse is Range(-9, -4)",
			"\tLength > 0 ? Range(ExclusiveEnd - 1 , Start - 1)\telse Range(ExclusiveEnd + 1, Start + 1)"));
		var character = new Type(this, new TypeLines(Base.Character,
			"has number",
			"from",
			"\tCharacter(7) is \"7\"",
			"\tCharacter(0) + number",
			"from(number)",
			"\tCharacter(7) is \"7\"",
			"\tCharacter(0) + number",
			"to Number",
			"\tCharacter(\"3\") to Number is 3",
			"\tmutable notANumber = Error",
			"\tCharacter(\"A\") to Number is notANumber",
			"\tconstant result = value - Character(0)",
			"\tresult is in Range(0, 10) ? result else notANumber(value)"));
		var mutable = new Type(this, new TypeLines(Base.Mutable,
			"has generic"));
		var iterator = new Type(this, new TypeLines(Base.Iterator,
			"for Iterator(Generic)",
			"in(element Generic) Boolean",
			"Length Number"));
		var list = new Type(this, new TypeLines(Base.List,
			"has iterator",
			"has elements Generics",
			"Length Number",
			"\t(1, 2).Length is 2",
			"\tmutable length = 0",
			"\tfor elements",
			"\t\tlength = length + 1",
			"\tlength",
			"+(other) List",
			"\t(1, 2, 3) + (4, 5) is (1, 2, 3, 4, 5)",
			"\t(\"Hello\", \"World\") + (1, 2) is (\"Hello\", \"World\", \"1\", \"2\")",
			"\tvalue + other",
			"+(addElement Generic) List",
			"\t(1, 2, 3) + 4 is (1, 2, 3, 4)",
			"\t(\"Hello\", \"World\") + 5 is (\"Hello\", \"World\", \"5\")",
			"\telements + addElement",
			"-(other) List",
			"\t(1, 2, 3) - (3) is (1, 2)",
			"\tvalue - other",
			"-(removeElement Generic) List",
			"\t(1, 2, 3) - 3 is (1, 2)",
			"\t(1, 2, 3) - 4 is (1, 2, 3)",
			"\telements - removeElement",
			"is(other) Boolean",
			"\tvalue is other",
			"*(other) List",
			"\t(1, 2) * (3, 5) is (3, 10)",
			"\tconstant listsHaveDifferentDimensions = Error",
			"\t(1) * (1, 2) is listsHaveDifferentDimensions",
			"\tif Length is not other.Length",
			"\t\tlistsHaveDifferentDimensions",
			"\telements * other.elements",
			"Contains(other Generic) Boolean",
			"\t(\"a\", \"b\", \"c\").Contains(\"d\") is false",
			"\t(\"a\", \"b\", \"c\").Contains(\"b\") is true",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn true",
			"\tfalse",
			"Index(other Generic) Number",
			"\t(1, 2, 3).Index(2) is 1",
			"\t(1, 2, 3).Index(9) is -1",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn index",
			"\treturn -1",
			"for Generic",
			"\tfor elements",
			"\t\treturn value",
			"in(other) Boolean",
			"\t3 is in (1, 2, 3)",
			"\t3 is not in (1, 2)",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn true",
			"\tfalse",
			"Add(element Generic) Mutable(List)",
			"\t(1, 2).Add(3) is (1, 2, 3)",
			"\tvalue = value + element",
			"Remove(element Generic) Mutable(List)",
			"\t(1, 2, 3).Remove(2) is (1, 3)",
			"\tvalue = value - element",
			"Count(element Generic) Number",
			"\t(1, 2).Count(1) is 1",
			"\t(1, 3).Count(2) is 0",
			"\t(\"Hi\", \"Hello\", \"Hi\").Count(\"Hi\") is 2",
			"\tmutable occurrenceCount = 0",
			"\tfor elements",
			"\t\tif element is value",
			"\t\t\toccurrenceCount.Increment",
			"\tcount"));
		var text = new Type(this, new TypeLines(Base.Text,
			"has characters",
			"has NewLine = Character(13)",
			"has Tab = Character(7)",
			"from(number)",
			"\tvalue",
			"from",
			"\tvalue",
			"Run",
			"\tvalue is not \"\"",
			"+(other) Text",
			"\treturn value",
			"digits(number) Numbers",
			"\tif floor(number / 10) is 0",
			"\t\treturn (number % 10)",
			"\telse",
			"\t\treturn digits(floor(number / 10)) + number % 10",
			"to Number",
			"\t\"3\" to Number is 3",
			"\tfor characters.Reverse",
			"\t\t+ value to Number * index ^ 10",
			"is(other) Boolean",
			"\t\"Hey\" is \"Hey\" is true",
			"\t\"Hi\" is \"Hey\" is false",
			"\tvalue is other",
			"is not(other) Boolean",
			"\t\"A\" is not \"B\"",
			"\t\"Hi\" is not \"hi\"",
			"\tvalue is not other"));
		var baseType = new Type(this, new TypeLines(Base.Type, "has Name",
			"has Package Text",
			"to Text",
			"\tto Text is \"Strict.Base.Type\"",
			"\tPackage + \".\" + Name"));
		var generic = new Type(this, new TypeLines(Base.Generic, "from(type)"));
		var log = new Type(this, new TypeLines(Base.Log,
			"has output",
			"Write(generic)",
			"\tSystem.WriteLine(generic)"));
		var file = new Type(this, new TypeLines(Base.File,
			"from(text)",
			"Read Text",
			"Write(text)",
			"Delete",
			"Length Number"));
		var output = new Type(this, new TypeLines(Base.Output, "Write(generic)"));
		var name = new Type(this, new TypeLines(Base.Name, "has text"));
		var error = new Type(this, new TypeLines(Base.Error, "has Text", "has Stacktraces"));
		var method = new Type(this, new TypeLines(Base.Method, "has Name", "has Type"));
		var stacktrace = new Type(this, new TypeLines(Base.Stacktrace,
			"has Method", "has FilePath Text", "has Line Number"));
		var dictionary = new Type(this, new TypeLines(Base.Dictionary,
			"has keysAndValues List(key Generic, mappedValue Generic)",
			"from",
			"\tDictionary(Number, Number).Length is 0",
			"\tDictionary(Number, Number) is Dictionary(Number, Number)",
			"\tDictionary(Number, Number) is not Dictionary(Number, Text)",
			"Add(key Generic, mappedValue Generic) Mutable(Dictionary)",
			"\tDictionary((2, 4)).Add(4, 8) is Dictionary((2, 4), (4, 8))",
			"\tDictionary((1, 1), (2, 2)).Add(3, 3).Length is 3",
			"\tkeysAndValues.Add((key, mappedValue))",
			"Get(key Generic) Generic",
			"\tfor keysAndValues",
			"\t\tif value(0) is key",
			"\t\t\treturn value(1)",
			"\tError(\"Key \" + key + \" not found\")"));
		// @formatter:on
		foreach (var type in new[]
			{
				any, boolean, hasLength, number, range, character, mutable, iterator, list, text,
				baseType, generic, log, file, output, name, error, method, stacktrace, dictionary
			})
			type.ParseMembersAndMethods(parser);
	}
}