namespace Strict.Language.Tests;

/// <summary>
/// Helper context to provide a bunch of helper types to make tests work.
/// </summary>
public class TestPackage : Package
{
	public static readonly Package Instance = new TestPackage();

	private TestPackage() : base(nameof(TestPackage))
	{
		var parser = new MethodExpressionParser();
		// @formatter:off
		var any = new Type(this, new TypeLines(Base.Any,
			"from", "to Type", "to Text", "is(other) Boolean"));
		var boolean = new Type(this, new TypeLines(Base.Boolean,
			"not Boolean",
			"\tnot true is false",
			"\tvalue ? false else true",
			"is(other) Boolean",
			"\tvalue is other",
			"and(other) Boolean",
			"\tvalue and other ? true else false",
			"or(other) Boolean",
			"\tvalue or other ? false else true",
			"xor(other) Boolean",
			"\ttrue xor false",
			"\tfalse xor false is false",
			"\tvalue and other or (not value) and (not other) ? false else true"));
		var hasLength = new Type(this, new TypeLines("HasLength","Length Number"));
		var number = new Type(this, new TypeLines(Base.Number,
			"to Character",
			"\t5 to Character is \"5\"",
			"\tconstant canOnlyConvertSingleDigit = Error",
			"\t13 to Character is canOnlyConvertSingleDigit",
			"\tvalue is in Range(0, 10) ? Character(Character.zeroCharacter + value) else canOnlyConvertSingleDigit(value)",
			"+(other) Number",
			"\t3 + 4 is 7",
			"\tvalue + other",
			"*(other) Number",
			"\tvalue * other",
			"-(other) Number",
			"\tvalue - other",
			"/(other) Number",
			"\tvalue / other",
			"Floor Number",
			"\tvalue - value % 1",
			"%(other) Number",
			"\tvalue % other",
			">(other) Boolean",
			"\tvalue > other",
			"<(other) Boolean",
			"\tvalue < other",
			">=(other) Boolean",
			"\tvalue >= other",
			"<=(other) Boolean",
			"\tvalue <= other",
			"^(other) Number",
			"\tvalue ^ other",
			"to Text",
			"\t5 to Text is \"5\"",
			"\t\"\" + value",
			"is(other) Boolean",
			"\t5 is 5",
			"\t6 is not 5",
			"\tvalue is other"));
		var range = new Type(this, new TypeLines(Base.Range,
			"has iterator",
			"has Start Number",
			"has ExclusiveEnd Number",
			"Length Number",
			"\tRange(0, 5).Length is 5",
			"\tRange(2, 18).Length is 16",
			"\tExclusiveEnd - Start",
			"in(number) Boolean",
			"\t3 is in Range(1, 4)",
			"\t5 is not in Range(1, 4)",
			"\t0 is not in Range(1, 4)",
			"\tnumber >= Start and number <= ExclusiveEnd",
			"Sum",
			"\tRange(2, 5).Sum is 2 + 3 + 4",
			"\tRange(42, 45).Sum is 42 + 43 + 44",
			"\tfor",
			"\t\tvalue",
			"for Iterator(Number)",
			"\tvalue",
			"Reverse Range",
			"\tRange(0, 5).Reverse is Range(4, -1)",
			"\tRange(1, 4).Reverse is Range(3, 0)",
			"\tRange(10, 5).Reverse is Range(6, 11)",
			"\tRange(-5, -10).Reverse is Range(-9, -4)",
			"\tLength > 0 ? Range(ExclusiveEnd - 1 , Start - 1) else Range(ExclusiveEnd + 1, Start + 1)"));
		var character = new Type(this, new TypeLines(Base.Character,
			"has number",
			"constant zeroCharacter = 48",
			"constant NewLine = Character(13)",
			"constant Tab = Character(7)",
			"to Number",
			"\tCharacter(\"3\") to Number is 3",
			"\tconstant notANumber = Error",
			"\tCharacter(\"A\") to Number is notANumber",
			"\tconstant result = number - zeroCharacter",
			"\tresult is in Range(0, 10) ? result else notANumber(value)"));
		var mutable = new Type(this, new TypeLines(Base.Mutable,
			"has generic"));
		var iterator = new Type(this, new TypeLines(Base.Iterator,
			"for Iterator(Generic)",
			"in(element Generic) Boolean",
			"Length Number"));
		var list = new Type(this, new TypeLines(Base.List,
			"has iterator",
			"has elements Generics",
			"Length Number",
			"\t(1, 2).Length is 2",
			"\tfor elements",
			"\t\t1",
			"+(other) List",
			"\t(1, 2, 3) + (4, 5) is (1, 2, 3, 4, 5)",
			"\t(\"Hello\", \"World\") + (1, 2) is (\"Hello\", \"World\", \"1\", \"2\")",
			"\tvalue + other",
			"+(addElement Generic) List",
			"\t(1, 2, 3) + 4 is (1, 2, 3, 4)",
			"\t(\"Hello\", \"World\") + 5 is (\"Hello\", \"World\", \"5\")",
			"\telements + addElement",
			"-(other) List",
			"\t(1, 2, 3) - (3) is (1, 2)",
			"\tvalue - other",
			"-(removeElement Generic) List",
			"\t(1, 2, 3) - 3 is (1, 2)",
			"\t(1, 2, 3) - 4 is (1, 2, 3)",
			"\telements - removeElement",
			"is(other) Boolean",
			"\tvalue is other",
			"*(other) List",
			"\t(1, 2) * (3, 5) is (3, 10)",
			"\tconstant listsHaveDifferentDimensions = Error",
			"\t(1) * (1, 2) is listsHaveDifferentDimensions",
			"\tif Length is not other.Length",
			"\t\tlistsHaveDifferentDimensions",
			"\telements * other.elements",
			"in(other Generic) Boolean",
			"\t\"d\" is not in (\"a\", \"b\", \"c\")",
			"\t\"b\" is in (\"a\", \"b\", \"c\")",
			"\tfor elements",
			"\t\tvalue is other",
			"Key Generic",
			"\telements(0)",
			"Value Generic",
			"\telements(1)",
			"Index(other Generic) Number",
			"\t(1, 2, 3).Index(2) is 1",
			"\t(1, 2, 3).Index(9) is -1",
			"\tfor elements",
			"\t\tif value is other",
			"\t\t\treturn index",
			"\t-1",
			"for Iterator",
			"\telements",
			"in(other) Boolean",
			"\t3 is in (1, 2, 3)",
			"\t3 is not in (1, 2)",
			"\tfor elements",
			"\t\tvalue is other",
			"Add(element Generic) Mutable(List)",
			"\t(1, 2).Add(3) is (1, 2, 3)",
			"\tvalue = value + element",
			"Remove(element Generic) Mutable(List)",
			"\t(1, 2, 3).Remove(2) is (1, 3)",
			"\tvalue = value - element",
			"Count(element Generic) Number",
			"\t(1, 2).Count(1) is 1",
			"\t(1, 3).Count(2) is 0",
			"\t(\"Hi\", \"Hello\", \"Hi\").Count(\"Hi\") is 2",
			"\tfor elements",
			"\t\tif element is value",
			"\t\t\t1"));
		var text = new Type(this, new TypeLines(Base.Text,
			"has characters",
			"from(number)",
			"\tvalue",
			"+(other) Text",
			"\tvalue + other",
			"digits(number) Numbers",
			"\tif floor(number / 10) is 0",
			"\t\treturn (number % 10)",
			"\telse",
			"\t\treturn digits(floor(number / 10)) + number % 10",
			"to Number",
			"\t\"3\" to Number is 3",
			"\tfor characters.Reverse",
			"\t\tvalue to Number * index ^ 10",
			"is(other) Boolean",
			"\t\"Hey\" is \"Hey\"",
			"\t\"Hi\" is not \"Hey\" is false",
			"\tvalue is other"));
		var baseType = new Type(this, new TypeLines(Base.Type, "has Name",
			"has Package Text",
			"to Text",
			"\tto Text is \"Strict.Base.Type\"",
			"\tPackage + \".\" + Name"));
		var generic = new Type(this, new TypeLines(Base.Generic, "from(type)"));
		var logger = new Type(this, new TypeLines(Base.Logger,
			"has textWriter",
			"Log(text)",
			"\ttextWriter.Write(text)"));
		var file = new Type(this, new TypeLines(Base.File,
			"from(text)",
			"Read Text",
			"Write(text)",
			"Delete",
			"Length Number"));
		var textWriter = new Type(this, new TypeLines(Base.TextWriter, "Write(text)"));
		var textReader = new Type(this, new TypeLines(Base.TextReader, "Read Text"));
		var name = new Type(this, new TypeLines(Base.Name, "has text"));
		var error = new Type(this, new TypeLines(Base.Error, "has Name", "has Stacktraces",
			"Text Text", "\tName to Text"));
		var errorWithValue = new Type(this, new TypeLines(Base.ErrorWithValue, "has Error",
			"has Value Generic"));
		var method = new Type(this, new TypeLines(Base.Method, "has Name", "has Type"));
		var stacktrace = new Type(this, new TypeLines(Base.Stacktrace,
			"has Method", "has FilePath Text", "has Line Number"));
		var dictionary = new Type(this, new TypeLines(Base.Dictionary,
			"has keysAndValues List(key Generic, mappedValue Generic)",
			"from",
			"\tDictionary(Number, Number).Length is 0",
			"\tDictionary(Number, Number) is Dictionary(Number, Number)",
			"\tDictionary(Number, Number) is not Dictionary(Number, Text)",
			"Add(key Generic, mappedValue Generic) Mutable(Dictionary)",
			"\tDictionary((2, 4)).Add(4, 8) is Dictionary((2, 4), (4, 8))",
			"\tDictionary((1, 1), (2, 2)).Add(3, 3).Length is 3",
			"\tkeysAndValues.Add((key, mappedValue))",
			"Get(key Generic) Generic",
			"\tfor keysAndValues",
			"\t\tif value.Key is key",
			"\t\t\treturn value.Value",
			"\tError(\"Key \" + key + \" not found\")"));
		// @formatter:on
		foreach (var type in new[]
			{
				any, boolean, hasLength, number, range, character, mutable, iterator, list, text, baseType,
				generic, logger, file, textWriter, textReader, name, error, errorWithValue, method, stacktrace,
				dictionary
			})
			type.ParseMembersAndMethods(parser);
	}
}